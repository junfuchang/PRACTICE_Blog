CREATE DATABASE  IF NOT EXISTS `bolg` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;
USE `bolg`;
-- MySQL dump 10.13  Distrib 8.0.32, for Win64 (x86_64)
--
-- Host: localhost    Database: bolg
-- ------------------------------------------------------
-- Server version	8.0.32

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `blog_config`
--

DROP TABLE IF EXISTS `blog_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_config` (
  `id` int NOT NULL,
  `title` varchar(20) NOT NULL,
  `sub_title` varchar(200) NOT NULL,
  `img_url` mediumtext,
  `slogan` varchar(200) NOT NULL,
  `qq` varchar(50) NOT NULL,
  `we_chat` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_config`
--

LOCK TABLES `blog_config` WRITE;
/*!40000 ALTER TABLE `blog_config` DISABLE KEYS */;
INSERT INTO `blog_config` VALUES (1,'BLOG','bolg_子标题','https://tse4-mm.cn.bing.net/th/id/OIP-C.zK_D_msJjzmYsCjccOaT5wHaNK?pid=ImgDet&rs=1','标语测试','qq号...','微信号...');
/*!40000 ALTER TABLE `blog_config` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_detail`
--

DROP TABLE IF EXISTS `blog_detail`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_detail` (
  `id` int NOT NULL AUTO_INCREMENT,
  `type_id` int NOT NULL,
  `title` varchar(50) NOT NULL,
  `add_time` tinytext NOT NULL,
  `introduce` text,
  `view_count` int DEFAULT NULL,
  `content` longtext,
  PRIMARY KEY (`id`),
  KEY `fk_blog_detail_blog_types` (`type_id`),
  CONSTRAINT `blog_detail_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `blog_types` (`id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_detail`
--

LOCK TABLES `blog_detail` WRITE;
/*!40000 ALTER TABLE `blog_detail` DISABLE KEYS */;
INSERT INTO `blog_detail` VALUES (1,3,'笔记DEMO','2022/12/9','笔记DEMO',23,'笔记DEMO笔记DEMO笔记DEMO笔记DEMO笔记DEMO'),(22,2,'测试文章','2022/11/23','测试文章',0,'# 测试文章\n# 标题1\n测试文章\n## 标题2\n测试文章'),(23,1,'NPM包管理工具','2022/12/1','# NPM\n\n官网：[npm (npmjs.com)](https://www.npmjs.com/)\n\n## npm安装\n\nnpm与node绑定，当装完node即可使用npm\n\n## npm镜像源\n\n~~~bash\n//查看当前镜像源\nnpm config get registry\n//设置淘宝镜像源\nnpm config set registry https://registry.npm.taobao.org\n//设置官方镜像源\nnpm config set registry https://registry.npmjs.org\n\n//使用nrm工具切换镜像源\nnpx nrm use taobao\nnpx nrm use npm\n\n//安装cnpm（可以单独用来下载国内资源）\nnpm i -g cnpm --registry=https://registry.npm.taobao.org\n~~~\n\n## npm的使用\n\n~~~bash\nnpm -v		//查看版本，可以判断npm是否安装成功\nnpm install <ModuleName>\nnpm install <ModuleName> -g		//全局安装\nnpm list -g		//查看所有全局安装的模块\nnpm list <ModuleName>		//查看某个模块的版本号\nnpm -g install npm@5.9.1		//安装指定版本的模块\nnpm insatll -save <ModuleName>		//-save在package文件的dependencies节点写入依赖（生产环境和开发环境都会用到的模块）\nnpm insatll -save-dev <ModuleName>		//-save-dev在package文件的devDependencies节点写入依赖（开发环境用到的模块）\n~~~',0,'# NPM\n\n官网：[npm (npmjs.com)](https://www.npmjs.com/)\n\n## npm安装\n\nnpm与node绑定，当装完node即可使用npm\n\n## npm镜像源\n\n~~~bash\n//查看当前镜像源\nnpm config get registry\n//设置淘宝镜像源\nnpm config set registry https://registry.npm.taobao.org\n//设置官方镜像源\nnpm config set registry https://registry.npmjs.org\n\n//使用nrm工具切换镜像源\nnpx nrm use taobao\nnpx nrm use npm\n\n//安装cnpm（可以单独用来下载国内资源）\nnpm i -g cnpm --registry=https://registry.npm.taobao.org\n~~~\n\n## npm的使用\n\n~~~bash\nnpm -v		//查看版本，可以判断npm是否安装成功\nnpm install <ModuleName>\nnpm install <ModuleName> -g		//全局安装\nnpm list -g		//查看所有全局安装的模块\nnpm list <ModuleName>		//查看某个模块的版本号\nnpm -g install npm@5.9.1		//安装指定版本的模块\nnpm insatll -save <ModuleName>		//-save在package文件的dependencies节点写入依赖（生产环境和开发环境都会用到的模块）\nnpm insatll -save-dev <ModuleName>		//-save-dev在package文件的devDependencies节点写入依赖（开发环境用到的模块）\n~~~\n\n## Package.json说明\n\n### 初始化package.json文件\n\n~~~bash\nnpm init\n\n//使用推荐配置进行初始化\nnpm init --yes\n~~~\n\n### 信息描述\n\n~~~bash\nname		包名\nversion		版本号\ndescription		包的描述\nhomepage		包的官网URL\nauthor		作者姓名\ncontributors		包的其他贡献者姓名\ndependencies		依赖包列表\nrepository		包代码存放的地方的类型，可以是git或者svn，git可在Github上\nmain	指定了程序的主入口文件，默认是index.js\nkeywords		关键字\n~~~\n\n### 版本号注意点\n\n~~~\n5.9.1		这种代表确切的一个版本\n^5.9.1		代表只固定大版本，如可更新至5.X.X\n~5.9.1		代表只能更新小版本，如可更新至5.9.X\n~~~\n\n\n\n# YARN\n\n## yarn安装\n\n~~~bash\nnpm instll -g yarn\n~~~\n\n## yarn镜像\n\n~~~bash\n//查看\nyarn config get registry\n//淘宝\nyarn config set registry https://registry.npm.taobao.org/\n//官方\nyarn config set registry https://registry.yarnpkg.com\n~~~\n\n## yarn的使用\n\n**yarn与npm极其相似**\n\n~~~bash\nyarn init\nyarn insatll		安装package.json中的所有包,并将包的所有依赖项保存进yarn.lock\nyarn install --flat		安装一个包的单一版本\nyarn install --force		强制重新下载所有包\nyarn install --production		只安装dependencies里的包\nyarn install --no-lockfile		不读取或生成yarn.lock\nyarn install --pure-lockfile		不生成yarn.lock\nyarn add <package>\nyarn add <package>@5.9.1		安装指定版本，指的是主要版本，小版本需要使用-E参数\nyarn add <package>@<tag>		安装某个tag（比如beta,next或latest）\nyarn add --dev/-D		加到devDependencies，开发时的依赖\nyarn add --peer/-P		加到peerDependencies，发布时配置的依赖\nyarn add --optional/-O		加到optionalDependencies，备选的依赖\n//yarn add --bundled/-B		加到bundledDependencies，使用非资源库中的包时使用\n\nyarn cache ls\nyarn add --offline <package>		使用本地的缓存添加包\n~~~\n\n\n\n# npm与yarn对比\n\n|             npm              |         yarn         |\n| :--------------------------: | :------------------: |\n|         npm install          |         yarn         |\n|   npm install react --save   |    yarn add react    |\n|  npm uninsatll react --save  |  yarn remove react   |\n| npm install react --save-dev | yarn add react --dev |\n|       npm udate --save       |     yarn upgrade     |'),(24,1,'webpack核心原理','2022/11/25','webpack核心原理：\n\n- 递归构建依赖关系图\n- 依赖关系图去引用模块\n- 将这些模块打包成一个或多个 *bundle*\n\n\n\n四个核心概念：\n\n- entry（入口）\n- output（出口）\n- loader\n- plugins（插件）\n\n\n\n# 一、Webpack 简介\n\n## 1.1 webpack 是什么\n\nwebpack 是一种**前端资源构建工具**，一个静态模块打包器(module bundler)。\n\n在webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。\n它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。\n\n## 1.2 webpack 五个核心概念\n\n#### 1.2.1 Entry\n\n入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。',0,'webpack核心原理：\n\n- 递归构建依赖关系图\n- 依赖关系图去引用模块\n- 将这些模块打包成一个或多个 *bundle*\n\n\n\n四个核心概念：\n\n- entry（入口）\n- output（出口）\n- loader\n- plugins（插件）\n\n\n\n# 一、Webpack 简介\n\n## 1.1 webpack 是什么\n\nwebpack 是一种**前端资源构建工具**，一个静态模块打包器(module bundler)。\n\n在webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。\n它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。\n\n## 1.2 webpack 五个核心概念\n\n#### 1.2.1 Entry\n\n入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。\n\n#### 1.2.2 Output\n\n输出(Output)：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。\n\n#### 1.2.3 Loader\n\nLoader：让 webpack 能够去处理那些非 JS 的文件，比如样式文件、图片文件(webpack 自身只理解\nJS)\n\n#### 1.2.4 Plugins\n\n插件(Plugins)：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，\n一直到重新定义环境中的变量等。\n\n#### 1.2.5 Mode\n\n模式(Mode)：指示 webpack 使用相应模式的配置。\n\n| 选项        | 描述                                                         | 特点                       |\n| ----------- | ------------------------------------------------------------ | -------------------------- |\n| development | 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 | 能让代码本地调试运行的环境 |\n| production  | 会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。 | 能让代码优化上线运行的环境 |\n\n# 二、Webpack 初体验\n\n## 2.1 初始化配置\n\n1. 初始化 package.json：npm init\n\n2. 下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)\n\n   全局安装：cnpm i webpack webpack-cli -g\n\n   本地安装：cnpm i webpack webpack-cli -D\n\n## 2.2 编译打包应用\n\n创建 src 下的 js 等文件后，不需要配置 webpack.config.js 文件，在命令行就可以编译打包。\n\n指令：\n\n- 开发环境：webpack ./src/index.js -o ./build/built.js --mode=development\n\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是开发环境\n\n- 生产环境：webpack ./src/index.js -o ./build/built.js --mode=production\n\n  webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是生产环境\n\n结论：\n\n1. webpack 本身能处理 js/json 资源，不能处理 css/img 等其他资源\n2. 生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化，但是不能处理 ES6 的基本语法转化为 ES5（需要借助 loader）\n3. 生产环境比开发环境多一个压缩 js 代码\n\n# 三、Webpack 开发环境的基本配置\n\nwebpack.config.js 是 webpack 的配置文件。\n\n作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）\n\n所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。\n\n开发环境配置主要是为了能让代码运行。主要考虑以下几个方面：\n\n- 打包样式资源\n- 打包 html 资源\n- 打包图片资源\n- 打包其他资源\n- devServer\n\n下面是一个简单的开发环境webpack.confg.js配置文件\n\n```\n// resolve用来拼接绝对路径的方法\nconst { resolve } = require(\'path\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\') // 引用plugin\n\nmodule.exports = {\n  // webpack配置\n  entry: \'./src/js/index.js\', // 入口起点\n  output: {\n    // 输出\n    // 输出文件名\n    filename: \'js/build.js\',\n    // __dirname是nodejs的变量，代表当前文件的目录绝对路径\n    path: resolve(__dirname, \'build\'), // 输出路径，所有资源打包都会输出到这个文件夹下\n  },\n  // loader配置\n  module: {\n    rules: [\n      // 详细的loader配置\n      // 不同文件必须配置不同loader处理\n      {\n        // 匹配哪些文件\n        test: /\\.less$/,\n        // 使用哪些loader进行处理\n        use: [\n          // use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)\n          // style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效\n          \'style-loader\',\n          // css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串\n          \'css-loader\',\n          // less-loader：将less文件编译成css文件，需要下载less-loader和less\n          \'less-loader\'\n        ],\n      },\n      {\n        test: /\\.css$/,\n        use: [\'style-loader\', \'css-loader\'],\n      },\n      {\n        // url-loader：处理图片资源，问题：默认处理不了html中的img图片\n        test: /\\.(jpg|png|gif)$/,\n        // 需要下载 url-loader file-loader\n        loader: \'url-loader\',\n        options: {\n          // 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）\n          // base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡\n          limit: 8 * 1024,\n          // 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名\n          name: \'[hash:10].[ext]\',\n          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]\n          // 解决：关闭url-loader的es6模块化，使用commonjs解析\n          esModule: false,\n          outputPath: \'imgs\',\n        },\n      },\n      {\n        test: /\\.html$/,\n        // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）\n        loader: \'html-loader\',\n      },\n      // 打包其他资源(除了html/js/css资源以外的资源)\n      {\n        // 排除html|js|css|less|jpg|png|gif文件\n        exclude: /\\.(html|js|css|less|jpg|png|gif)/,\n        // file-loader：处理其他文件\n        loader: \'file-loader\',\n        options: {\n          name: \'[hash:10].[ext]\',\n          outputPath: \'media\',\n        },\n      },\n    ],\n  },\n  // plugin的配置\n  plugins: [\n    // html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）\n    // 需要有结构的HTML文件可以加一个template\n    new HtmlWebpackPlugin({\n      // 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）\n      template: \'./src/index.html\',\n    }),\n  ],\n  // 模式\n  mode: \'development\', // 开发模式\n  // 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）\n  // 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）\n  // 启动devServer指令为：npx webpack-dev-server\n  devServer: {\n    // 项目构建后路径\n    contentBase: resolve(__dirname, \'build\'),\n    // 启动gzip压缩\n    compress: true,\n    // 端口号\n    port: 3000,\n    // 自动打开浏览器\n    open: true,\n  },\n}\n```\n\n其中，大部分配置都在注释中给出解释。\n\n- 运行项目的两个指令：\n  webpack 会将打包结果输出出去（build文件夹）\n  npx webpack-dev-server 只会在内存中编译打包，没有输出\n\n- loader 和 plugin 的不同：（plugin 一定要先引入才能使用）\n\n  loader：1. 下载 2. 使用（配置 loader）\n\n  plugins：1.下载 2. 引入 3. 使用\n\n# 四、Webpack 生产环境的基本配置\n\n而生产环境的配置需要考虑以下几个方面：\n\n- 提取 css 成单独文件\n- css 兼容性处理\n- 压缩 css\n- js 语法检查\n- js 兼容性处理\n- js 压缩\n- html 压缩\n\n下面是一个基本的生产环境下的webpack.config.js配置\n\n```\nconst { resolve } = require(\'path\')\nconst MiniCssExtractorPlugin = require(\'mini-css-extract-plugin\')\nconst OptimiziCssAssetsWebpackPlugin = require(\'optimizi-css-assets-webpack-plugin\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\n// 定义node.js的环境变量，决定使用browserslist的哪个环境\nprocess.env.NODE_ENV = \'production\'\n\n// 复用loader的写法\nconst commonCssLoader = [\n  // 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载\n  MiniCssExtractPlugin.loader,\n  // css-loader：将css文件整合到js文件中\n  // 经过css-loader处理后，样式文件是在js文件中的\n  // 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象\n  // 解决：用MiniCssExtractPlugin.loader替代style-loader\n  \'css-loader\',\n  /*\n    postcss-loader：css兼容性处理：postcss --> 需要安装：postcss-loader postcss-preset-env\n    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式\n    在package.json中定义browserslist：\n    \"browserslist\": {\n      // 开发环境 --> 设置node环境变量：process.env.NODE_ENV = development\n      \"development\": [ // 只需要可以运行即可\n        \"last 1 chrome version\",\n        \"last 1 firefox version\",\n        \"last 1 safari version\"\n      ],\n      // 生产环境。默认是生产环境\n      \"production\": [ // 需要满足绝大多数浏览器的兼容\n        \">0.2%\",\n        \"not dead\",\n        \"not op_mini all\"\n      ]\n    },\n  */\n  {\n    loader: \'postcss-loader\',\n    options: {\n      ident: \'postcss\', // 基本写法\n      plugins: () => [\n        // postcss的插件\n        require(\'postcss-preset-env\')(),\n      ],\n    },\n  },\n]\n\nmodule.exports = {\n  entry: \'./src/js/index.js\',\n  output: {\n    filename: \'js/built.js\',\n    path: resolve(__dirname, \'build\'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [...commonCssLoader],\n      },\n      {\n        test: /\\.less$/,\n        use: [...commonCssLoader, \'less-loader\'],\n      },\n      /*\n        正常来讲，一个文件只能被一个loader处理\n        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序\n        先执行eslint再执行babel（用enforce）\n      */\n      {\n        /*\n          js的语法检查： 需要下载 eslint-loader eslint\n          注意：只检查自己写的源代码，第三方的库是不用检查的\n          airbnb(一个流行的js风格) --> 需要下载 eslint-config-airbnb-base eslint-plugin-import\n          设置检查规则：\n            package.json中eslintConfig中设置\n              \"eslintConfig\": {\n                \"extends\": \"airbnb-base\"， // 继承airbnb的风格规范\n                \"env\": {\n                  \"browser\": true // 可以使用浏览器中的全局变量(使用window不会报错)\n                }\n              }\n        */\n        test: /\\.js$/,\n        exclude: /node_modules/, // 忽略node_modules\n        enforce: \'pre\', // 优先执行\n        loader: \'eslint-loader\',\n        options: {\n          // 自动修复\n          fix: true,\n        },\n      },\n      /*\n        js兼容性处理：需要下载 babel-loader @babel/core\n          1. 基本js兼容性处理 --> @babel/preset-env\n            问题：只能转换基本语法，如promise高级语法不能转换\n          2. 全部js兼容性处理 --> @babel/polyfill\n            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了\n          3. 需要做兼容性处理的就做：按需加载  --> core-js\n      */\n      {\n        // 第三种方式：按需加载\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \'babel-loader\',\n        options: {\n          // 预设：指示babel做怎样的兼容性处理\n          presets: [\n            \'@babel/preset-env\', // 基本预设\n            {\n              useBuiltIns: \'usage\', //按需加载\n              corejs: { version: 3 }, // 指定core-js版本\n              targets: { // 指定兼容到什么版本的浏览器\n                chrome: \'60\',\n                firefox: \'50\',\n                ie: \'9\',\n                safari: \'10\',\n                edge: \'17\'\n              },\n            },\n          ],\n        },\n      },\n      {\n        // 图片处理\n        test: /\\.(jpg|png|gif)/,\n        loader: \'url-loader\',\n        options: {\n          limit: 8 * 1024,\n          name: \'[hash:10].[ext]\',\n          outputPath: \'imgs\',\n          esModule: false, // 关闭url-loader默认使用的es6模块化解析\n        },\n      },\n      // html中的图片处理\n      {\n        test: /\\.html$/,\n        loader: \'html-loader\',\n      },\n      // 处理其他文件\n      {\n        exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n        loader: \'file-loader\',\n        options: {\n          outputPath: \'media\',\n        },\n      },\n    ],\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      // 对输出的css文件进行重命名\n      filename: \'css/built.css\',\n    }),\n    // 压缩css\n    new OptimiziCssAssetsWebpackPlugin(),\n    // HtmlWebpackPlugin：html文件的打包和压缩处理\n    // 通过这个插件会自动将单独打包的样式文件通过link标签引入\n    new HtmlWebpackPlugin({\n      template: \'./src/index.html\',\n      // 压缩html代码\n      minify: {\n        // 移除空格\n        collapseWhitespace: true,\n        // 移除注释\n        removeComments: true,\n      },\n    }),\n  ],\n  // 生产环境下会自动压缩js代码\n  mode: \'production\',\n}\n```\n\n# 五、Webpack 优化配置\n\n## 5.1 开发环境性能优化\n\n### 5.1.1 HMR（模块热替换）\n\nHMR: hot module replacement 热模块替换 / 模块热替换\n\n作用：一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度\n\n代码：只需要在 devServer 中设置 hot 为 true，就会自动开启HMR功能（只能在开发模式下使用）\n\n```\ndevServer: {\n  contentBase: resolve(__dirname, \'build\'),\n  compress: true,\n  port: 3000,\n  open: true,\n  // 开启HMR功能\n  // 当修改了webpack配置，新配置要想生效，必须重启webpack服务\n  hot: true\n}\n```\n\n每种文件实现热模块替换的情况：\n\n- 样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能\n\n- js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）\n\n  --> 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）\n\n  ```\n  // 绑定\n  if (module.hot) {\n    // 一旦 module.hot 为true，说明开启了HMR功能。 --> 让HMR功能代码生效\n    module.hot.accept(\'./print.js\', function() {\n      // 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。\n      // 会执行后面的回调函数\n      print();\n    });\n  }\n  ```\n\n  注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。\n\n- html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）\n\n  使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）\n\n  解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）\n\n  ```\n  entry: [\'./src/js/index.js\', \'./src/index.html\']\n  ```\n\n### 5.1.2 source-map\n\nsource-map：一种提供**源代码到构建后代码的映射**的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）\n\n参数：`[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map`\n\n代码：\n\n```\ndevtool: \'eval-source-map\'\n```\n\n可选方案：[生成source-map的位置|给出的错误代码信息]\n\n- source-map：外部，错误代码准确信息 和 源代码的错误位置\n- inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置\n- hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置\n- eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位\n- nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）\n- cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列\n- cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map\n\n内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快\n\n开发/生产环境可做的选择：\n\n**开发环境**：需要考虑速度快，调试更友好\n\n- 速度快( eval > inline > cheap >... )\n  1. eval-cheap-souce-map\n  2. eval-source-map\n- 调试更友好\n  1. souce-map\n  2. cheap-module-souce-map\n  3. cheap-souce-map\n\n**最终得出最好的两种方案 --> eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）**\n\n**生产环境**：需要考虑源代码要不要隐藏，调试要不要更友好\n\n- 内联会让代码体积变大，所以在生产环境不用内联\n- 隐藏源代码\n  1. nosources-source-map 全部隐藏\n  2. hidden-source-map 只隐藏源代码，会提示构建后代码错误信息\n\n**最终得出最好的两种方案 --> source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）**\n\n## 5.2 生产环境性能优化\n\n### 5.2.1 优化打包构建速度\n\n#### 5.2.1.1 oneOf\n\noneOf：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度\n\n代码：\n\n```\nmodule: {\n  rules: [\n    {\n      // js 语法检查\n      test: /\\.js$/,\n      exclude: /node_modules/,\n      // 优先执行\n      enforce: \'pre\',\n      loader: \'eslint-loader\',\n      options: {\n        fix: true\n      }\n    },\n    {\n      // oneOf 优化生产环境的打包构建速度\n      // 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）\n      // 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）\n      oneOf: [\n        {\n          test: /\\.css$/,\n          use: [...commonCssLoader]\n        },\n        {\n          test: /\\.less$/,\n          use: [...commonCssLoader, \'less-loader\']\n        },\n        {\n          // js 兼容性处理\n          test: /\\.js$/,\n          exclude: /node_modules/,\n          loader: \'babel-loader\',\n          options: {\n            presets: [\n              [\n                \'@babel/preset-env\',\n                {\n                  useBuiltIns: \'usage\',\n                  corejs: {version: 3},\n                  targets: {\n                    chrome: \'60\',\n                    firefox: \'50\'\n                  }\n                }\n              ]\n            ]\n          }\n        },\n        {\n          test: /\\.(jpg|png|gif)/,\n          loader: \'url-loader\',\n          options: {\n            limit: 8 * 1024,\n            name: \'[hash:10].[ext]\',\n            outputPath: \'imgs\',\n            esModule: false\n          }\n        },\n        {\n          test: /\\.html$/,\n          loader: \'html-loader\'\n        },\n        {\n          exclude: /\\.(js|css|less|html|jpg|png|gif)/,\n          loader: \'file-loader\',\n          options: {\n            outputPath: \'media\'\n          }\n        }\n      ]\n    }\n  ]\n},\n```\n\n#### 5.2.1.2 babel 缓存\n\n**babel 缓存**：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快\n\n代码：\n\n```\n{\n  test: /\\.js$/,\n  exclude: /node_modules/,\n  loader: \'babel-loader\',\n  options: {\n    presets: [\n      [\n        \'@babel/preset-env\',\n        {\n          useBuiltIns: \'usage\',\n          corejs: { version: 3 },\n          targets: {\n            chrome: \'60\',\n            firefox: \'50\'\n          }\n        }\n      ]\n    ],\n    // 开启babel缓存\n    // 第二次构建时，会读取之前的缓存\n    cacheDirectory: true\n  }\n},\n```\n\n**文件资源缓存**\n\n文件名不变，就不会重新请求，而是再次用之前缓存的资源\n\n1.hash: 每次 wepack 打包时会生成一个唯一的 hash 值。\n\n 问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）\n\n2.chunkhash：根据 chunk 生成的 hash 值。来源于同一个 chunk的 hash 值一样\n\n 问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，所以同属于一个chunk）\n\n3.contenthash: 根据文件的内容生成 hash 值。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)\n\n修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 --> 让代码上线运行缓存更好使用\n\n#### 5.2.1.3 多进程打包\n\n多进程打包：某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。\n\n优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）\n\n```\n{\n  test: /\\.js$/,\n  exclude: /node_modules/,\n  use: [\n    /* \n      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 \n      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)\n      只有工作消耗时间比较长，才需要多进程打包\n    */\n    {\n      loader: \'thread-loader\',\n      options: {\n        workers: 2 // 进程2个\n      }\n    },\n    {\n      loader: \'babel-loader\',\n      options: {\n        presets: [\n          [\n            \'@babel/preset-env\',\n            {\n              useBuiltIns: \'usage\',\n              corejs: { version: 3 },\n              targets: {\n                chrome: \'60\',\n                firefox: \'50\'\n              }\n            }\n          ]\n        ],\n        // 开启babel缓存\n        // 第二次构建时，会读取之前的缓存\n        cacheDirectory: true\n      }\n    }\n  ]\n},\n```\n\n#### 5.2.1.4 externals\n\nexternals：让某些库不打包，通过 cdn 引入\n\nwebpack.config.js 中配置：\n\n```\nexternals: {\n  // 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)\n  // 忽略的库名 -- npm包名\n  jquery: \'jQuery\'\n}\n```\n\n需要在 index.html 中通过 cdn 引入：\n\n```\n<script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"></script>\n```\n\n#### 5.2.1.5 dll\n\ndll：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。\n\nwebpack.dll.js 配置：(将 jquery 单独打包)\n\n```\n/*\n  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了\n  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包\n  当运行webpack时，默认查找webpack.config.js配置文件\n  需求：需要运行webpack.dll.js文件\n    --> webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）\n*/\nconst { resolve } = require(\'path\');\nconst webpack = require(\'webpack\');\n\nmodule.exports = {\n  entry: {\n    // 最终打包生成的[name] --> jquery\n    // [\'jquery] --> 要打包的库是jquery\n    jquery: [\'jquery\']\n  },\n  output: {\n    // 输出出口指定\n    filename: \'[name].js\', // name就是jquery\n    path: resolve(__dirname, \'dll\'), // 打包到dll目录下\n    library: \'[name]_[hash]\', // 打包的库里面向外暴露出去的内容叫什么名字\n  },\n  plugins: [\n    // 打包生成一个manifest.json --> 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）\n    new webpack.DllPlugin({\n      name: \'[name]_[hash]\', // 映射库的暴露的内容名称\n      path: resolve(__dirname, \'dll/manifest.json\') // 输出文件路径\n    })\n  ],\n  mode: \'production\'\n};\n```\n\nwebpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)\n\n```\n// 引入插件\nconst webpack = require(\'webpack\');\nconst AddAssetHtmlWebpackPlugin = require(\'add-asset-html-webpack-plugin\');\n\n// plugins中配置：\nplugins: [\n  new HtmlWebpackPlugin({\n    template: \'./src/index.html\'\n  }),\n  // 告诉webpack哪些库不参与打包，同时使用时的名称也得变\n  new webpack.DllReferencePlugin({\n    manifest: resolve(__dirname, \'dll/manifest.json\')\n  }),\n  // 将某个文件打包输出到build目录下，并在html中自动引入该资源\n  new AddAssetHtmlWebpackPlugin({\n    filepath: resolve(__dirname, \'dll/jquery.js\')\n  })\n],\n```\n\n### 5.2.2 优化代码运行的性能\n\n#### 5.2.2.1 缓存\n\n#### 5.2.2.2 tree shaking（树摇）\n\ntree shaking：去除无用代码\n\n前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）\n\n作用：减少代码体积\n\n在 package.json 中配置：\n\n`\"sideEffects\": false` 表示所有代码都没有副作用（都可以进行 tree shaking）\n\n这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）\n\n所以可以配置：`\"sideEffects\": [\"*.css\", \"*.less\"]` 不会对css/less文件tree shaking处理\n\n#### 5.2.2.3 code split（代码分割）\n\n代码分割。将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。\n\n1.多入口拆分\n\n```\nentry: {\n    // 多入口：有一个入口，最终输出就有一个bundle\n    index: \'./src/js/index.js\',\n    test: \'./src/js/test.js\'\n  },\n  output: {\n    // [name]：取文件名\n    filename: \'js/[name].[contenthash:10].js\',\n    path: resolve(__dirname, \'build\')\n  },\n```\n\n2.optimization：\n\n```\noptimization: {\n    splitChunks: {\n      chunks: \'all\'\n    }\n  },\n```\n\n- 将 node_modules 中的代码单独打包（大小超过30kb）\n- 自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）\n\n3.import 动态导入语法：\n\n```\n/*\n  通过js代码，让某个文件被单独打包成一个chunk\n  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)\n  webpackChunkName:指定test单独打包后文件的名字\n*/\nimport(/* webpackChunkName: \'test\' */\'./test\')\n  .then(({ mul, count }) => {\n    // 文件加载成功~\n    // eslint-disable-next-line\n    console.log(mul(2, 5));\n  })\n  .catch(() => {\n    // eslint-disable-next-line\n    console.log(\'文件加载失败~\');\n  });\n```\n\n#### 5.2.2.4 lazy loading（懒加载/预加载）\n\n1.懒加载：当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。\n\n2.正常加载：可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。\n\n3.预加载 prefetch（兼容性很差）：会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。\n\n代码：\n\n```\ndocument.getElementById(\'btn\').onclick = function() {\n  // 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)\n  // webpackPrefetch: true表示开启预加载\n  import(/* webpackChunkName: \'test\', webpackPrefetch: true */\'./test\').then(({ mul }) => {\n    console.log(mul(4, 5));\n  });\n  import(\'./test\').then(({ mul }) => {\n    console.log(mul(2, 5))\n  })\n};\n```\n\n#### 5.2.2.5 pwa（离线可访问技术）\n\npwa：离线可访问技术（渐进式网络开发应用程序），使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。\n\nwebpack.config.js 中配置：\n\n```\nconst WorkboxWebpackPlugin = require(\'workbox-webpack-plugin\'); // 引入插件\n\n// plugins中加入：\nnew WorkboxWebpackPlugin.GenerateSW({\n  /*\n    1. 帮助serviceworker快速启动\n    2. 删除旧的 serviceworker\n\n    生成一个 serviceworker 配置文件\n  */\n  clientsClaim: true,\n  skipWaiting: true\n})\n```\n\nindex.js 中还需要写一段代码来激活它的使用：\n\n```\n/*\n  1. eslint不认识 window、navigator全局变量\n    解决：需要修改package.json中eslintConfig配置\n    \"env\": {\n      \"browser\": true // 支持浏览器端全局变量\n    }\n  2. sw代码必须运行在服务器上\n    --> nodejs\n    或-->\n      npm i serve -g\n      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去\n*/\nif (\'serviceWorker\' in navigator) { // 处理兼容性问题\n  window.addEventListener(\'load\', () => {\n    navigator.serviceWorker\n      .register(\'/service-worker.js\') // 注册serviceWorker\n      .then(() => {\n        console.log(\'sw注册成功了~\');\n      })\n      .catch(() => {\n        console.log(\'sw注册失败了~\');\n      });\n  });\n}\n```\n\n# 六、Webpack 配置详情\n\n## 6.1 entry\n\nentry: 入口起点\n\n1. string --> \'./src/index.js\'，单入口\n\n   打包形成一个 chunk。 输出一个 bundle 文件。此时 chunk 的名称默认是 main\n\n2. array --> [\'./src/index.js\', \'./src/add.js\']，多入口\n\n   所有入口文件最终只会形成一个 chunk，输出出去只有一个 bundle 文件。\n\n   （一般只用在 HMR 功能中让 html 热更新生效）\n\n3. object，多入口\n\n   有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 的名称是 key 值\n\n--> 特殊用法：\n\n```\nentry: {\n  // 最终只会形成一个chunk, 输出出去只有一个bundle文件。\n  index: [\'./src/index.js\', \'./src/count.js\'], \n  // 形成一个chunk，输出一个bundle文件。\n  add: \'./src/add.js\'\n}\n```\n\n## 6.2 output\n\n```\noutput: {\n  // 文件名称（指定名称+目录）\n  filename: \'js/[name].js\',\n  // 输出文件目录（将来所有资源输出的公共目录）\n  path: resolve(__dirname, \'build\'),\n  // 所有资源引入公共路径前缀 --> \'imgs/a.jpg\' --> \'/imgs/a.jpg\'\n  publicPath: \'/\',\n  chunkFilename: \'js/[name]_chunk.js\', // 指定非入口chunk的名称\n  library: \'[name]\', // 打包整个库后向外暴露的变量名\n  libraryTarget: \'window\' // 变量名添加到哪个上 browser：window\n  // libraryTarget: \'global\' // node：global\n  // libraryTarget: \'commonjs\' // conmmonjs模块 exports\n},\n```\n\n## 6.3 module\n\n```\nmodule: {\n  rules: [\n    // loader的配置\n    {\n      test: /\\.css$/,\n      // 多个loader用use\n      use: [\'style-loader\', \'css-loader\']\n    },\n    {\n      test: /\\.js$/,\n      // 排除node_modules下的js文件\n      exclude: /node_modules/,\n      // 只检查src下的js文件\n      include: resolve(__dirname, \'src\'),\n      enforce: \'pre\', // 优先执行\n      // enforce: \'post\', // 延后执行\n      // 单个loader用loader\n      loader: \'eslint-loader\',\n      options: {} // 指定配置选项\n    },\n    {\n      // 以下配置只会生效一个\n      oneOf: []\n    }\n  ]\n},\n```\n\n## 6.4 resolve\n\n```\n// 解析模块的规则\nresolve: {\n  // 配置解析模块路径别名: 优点：当目录层级很复杂时，简写路径；缺点：路径不会提示\n  alias: {\n    $css: resolve(__dirname, \'src/css\')\n  },\n  // 配置省略文件路径的后缀名（引入时就可以不写文件后缀名了）\n  extensions: [\'.js\', \'.json\', \'.jsx\', \'.css\'],\n  // 告诉 webpack 解析模块应该去找哪个目录\n  modules: [resolve(__dirname, \'../../node_modules\'), \'node_modules\']\n}\n```\n\n这样配置后，引入文件就可以这样简写：`import \'$css/index\';`\n\n## 6.5 dev server\n\n```\ndevServer: {\n  // 运行代码所在的目录\n  contentBase: resolve(__dirname, \'build\'),\n  // 监视contentBase目录下的所有文件，一旦文件变化就会reload\n  watchContentBase: true,\n  watchOptions: {\n    // 忽略文件\n    ignored: /node_modules/\n  },\n  // 启动gzip压缩\n  compress: true,\n  // 端口号\n  port: 5000,\n  // 域名\n  host: \'localhost\',\n  // 自动打开浏览器\n  open: true,\n  // 开启HMR功能\n  hot: true,\n  // 不要显示启动服务器日志信息\n  clientLogLevel: \'none\',\n  // 除了一些基本信息外，其他内容都不要显示\n  quiet: true,\n  // 如果出错了，不要全屏提示\n  overlay: false,\n  // 服务器代理，--> 解决开发环境跨域问题\n  proxy: {\n    // 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000\n    \'/api\': {\n      target: \'http://localhost:3000\',\n      // 发送请求时，请求路径重写：将/api/xxx --> /xxx （去掉/api）\n      pathRewrite: {\n        \'^/api\': \'\'\n      }\n    }\n  }\n}\n```\n\n其中，跨域问题：同源策略中不同的协议、端口号、域名就会产生跨域。\n\n正常的浏览器和服务器之间有跨域，但是服务器之间没有跨域。代码通过代理服务器运行，所以浏览器和代理服务器之间没有跨域，浏览器把请求发送到代理服务器上，代理服务器替你转发到另外一个服务器上，服务器之间没有跨域，所以请求成功。代理服务器再把接收到的响应响应给浏览器。这样就解决开发环境下的跨域问题。\n\n## 6.6 optimization\n\ncontenthash 缓存会导致一个问题：修改 a 文件导致 b 文件 contenthash 变化。\n因为在 index.js 中引入 a.js，打包后 index.js 中记录了 a.js 的 hash 值，而 a.js 改变，其重新打包后的 hash 改变，导致 index.js 文件内容中记录的 a.js 的 hash 也改变，从而重新打包后 index.js 的 hash 值也会变，这样就会使缓存失效。（改变的是a.js文件但是 index.js 文件的 hash 值也改变了）\n解决办法：runtimeChunk --> 将当前模块记录其他模块的 hash 单独打包为一个文件 runtime，这样 a.js 的 hash 改变只会影响 runtime 文件，不会影响到 index.js 文件\n\n```\noutput: {\n  filename: \'js/[name].[contenthash:10].js\',\n  path: resolve(__dirname, \'build\'),\n  chunkFilename: \'js/[name].[contenthash:10]_chunk.js\' // 指定非入口文件的其他chunk的名字加_chunk\n},\noptimization: {\n  splitChunks: {\n    chunks: \'all\',\n    /* 以下都是splitChunks默认配置，可以不写\n    miniSize: 30 * 1024, // 分割的chunk最小为30kb（大于30kb的才分割）\n    maxSize: 0, // 最大没有限制\n    minChunks: 1, // 要提取的chunk最少被引用1次\n    maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量为5\n    maxInitialRequests: 3, // 入口js文件最大并行请求数量\n    automaticNameDelimiter: \'~\', // 名称连接符\n    name: true, // 可以使用命名规则\n    cacheGroups: { // 分割chunk的组\n      vendors: {\n        // node_modules中的文件会被打包到vendors组的chunk中，--> vendors~xxx.js\n        // 满足上面的公共规则，大小超过30kb、至少被引用一次\n        test: /[\\\\/]node_modules[\\\\/]/,\n        // 优先级\n        priority: -10\n      },\n      default: {\n        // 要提取的chunk最少被引用2次\n        minChunks: 2,\n        prority: -20,\n        // 如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包\n        reuseExistingChunk: true\n      }\n    } */\n  },\n  // 将index.js记录的a.js的hash值单独打包到runtime文件中\n  runtimeChunk: {\n    name: entrypoint => `runtime-${entrypoint.name}`\n  },\n  minimizer: [\n    // 配置生产环境的压缩方案：js/css\n    new TerserWebpackPlugin({\n      // 开启缓存\n      cache: true,\n      // 开启多进程打包\n      parallel: true,\n      // 启用sourceMap(否则会被压缩掉)\n      sourceMap: true\n    })\n  ]\n}\n```\n\n# 七、Webpack5 介绍和使用\n\n此版本重点关注以下内容:\n\n- 通过持久缓存提高构建性能.\n- 使用更好的算法和默认值来改善长期缓存.\n- 通过更好的树摇和代码生成来改善捆绑包大小.\n- 清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改.\n- 通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5.\n\n## 下载\n\nnpm i webpack@next webpack-cli -D\n\n## 自动删除 Node.js Polyfills\n\n早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack <= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。\n\n尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。\n\nwebpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。\n\n迁移：\n\n- 尽可能尝试使用与前端兼容的模块。\n- 可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。\n\nChunk 和模块 ID\n\n添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。\n\n```\nchunkIds: \"deterministic\", moduleIds: \"deterministic\"\n```\n\n## Chunk ID\n\n你可以不用使用 `import(/* webpackChunkName: \"name\" */ \"module\")` 在开发环境来为 chunk 命名，生产环境还是有必要的\n\nwebpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了\n\n## Tree Shaking\n\n1. webpack 现在能够处理对嵌套模块的 tree shaking\n\n```\n// inner.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nimport * as inner from \'./inner\';\nexport { inner };\n\n// user.js\nimport * as module from \'./module\';\nconsole.log(module.inner.a);\n```\n\n在生产环境中, inner 模块暴露的 `b` 会被删除\n\n1. webpack 现在能够多个模块之前的关系\n\n```\nimport { something } from \'./something\';\n\nfunction usingSomething() {\n  return something;\n}\n\nexport function test() {\n  return usingSomething();\n}\n```\n\n当设置了`\"sideEffects\": false`时，一旦发现`test`方法没有使用，不但删除`test`，还会删除`\"./something\"`\n\n1. webpack 现在能处理对 Commonjs 的 tree shaking\n\n## Output\n\nwebpack 4 默认只能输出 ES5 代码\n\nwebpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.\n\n如：`output.ecmaVersion: 2015`\n\nSplitChunk\n\n```\n// webpack4\nminSize: 30000;\n// webpack5\nminSize: {\n  javascript: 30000,\n  style: 50000,\n}\n```\n\n## Caching\n\n```\n// 配置缓存\ncache: {\n  // 磁盘存储\n  type: \"filesystem\",\n  buildDependencies: {\n    // 当配置修改时，缓存失效\n    config: [__filename]\n  }\n}\n```\n\n缓存将存储到 `node_modules/.cache/webpack`\n\n## 监视输出文件\n\n之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。\n\n此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。\n\n## 默认值\n\n- `entry: \"./src/index.js`\n- `output.path: path.resolve(__dirname, \"dist\")`\n- `output.filename: \"[name].js\"`');
/*!40000 ALTER TABLE `blog_detail` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_types`
--

DROP TABLE IF EXISTS `blog_types`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_types` (
  `id` int NOT NULL AUTO_INCREMENT,
  `type_name` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_types`
--

LOCK TABLES `blog_types` WRITE;
/*!40000 ALTER TABLE `blog_types` DISABLE KEYS */;
INSERT INTO `blog_types` VALUES (1,'笔记'),(2,'日志'),(3,'其他');
/*!40000 ALTER TABLE `blog_types` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_table`
--

DROP TABLE IF EXISTS `user_table`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_table` (
  `id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL,
  `password` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_table`
--

LOCK TABLES `user_table` WRITE;
/*!40000 ALTER TABLE `user_table` DISABLE KEYS */;
INSERT INTO `user_table` VALUES (1,'admin','123456');
/*!40000 ALTER TABLE `user_table` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-03-03  0:21:15
